#!/usr/bin/env python

import csv
import sys
import os
# Description :
"""
    The program accepts the network topology details in terms of the cost of links, and provides the shortest path tree for the
    network. It uses Dijkstra's Algorithm to construct its routing table.
Link state algorithm:
    1 * Each router establishes a relationship an adjacency with each of its neighbors.
    2 * Each router sends link state advertisements (LSAs), some
    3 * Each router stores a copy of all the LSAs it has seen in a database. If all works well, the databases in all routers should be identical.
    4 * The completed topological database, also called the link state database, describes a graph of the internetwork. Using the Dijkstra algorithm, each router calculates the shortest path to each network and enters this information into the route table.

ref: http://www.ciscopress.com/articles/article.asp?p=24090&seqNum=4
"""
NUM_NODES = 8
router_matrix = []
matrix_set = 0
nodes = []
distances = {}
unvisited = {}
previous = {}
visited = {}
interface = {}
path = []
start = 0
end = 0

def print_choices():
    print "\nLink State Routing Simulator\n"
    print "(1) Input Network Topology File"
    print "(2) Build a Connection Table"
    print "(3) Shortest Path to Destination Router"
    print "(4) Exit"
    pass

def check_choices(command):
        
    if not command.isdigit():
        print "Please enter a number as command from given choices.."
        return -1
    else:
        command = int(command)
        
        if command > 4 or command < 1 :
            print "Please enter a valid command from given choices.."
            return -1
        else:
            return command


def process_file(fname):
    
    global matrix_set
    global router_matrix
    matrix_set = 0
    router_matrix = []

    with open(fname) as f:
        router_matrix=[list(map(int,x.split(" "))) for x in f]      # Data from input file is stored in a two dimensional list(array).
    matrix_set = 1

    print "\noriginal topology matrix:\n"
    for line in router_matrix :
        for item in line :
            print item,
        print
    print

    set_distances(router_matrix)        # Distances are stored in a dictionary - key,value pair - with source router as key and distances in form of a dictionary as value.


# Function to store the distances in dictionary format.
def set_distances(router_matrix):

    global distances
    global nodes
    
    distances = {}
    nodes = []

    num_nodes = len(router_matrix)

    for i in xrange(num_nodes):
        tempdict = {}
        for j in xrange(num_nodes):
            if i!=j and router_matrix[i][j]!=-1:
                tempdict[j+1] = router_matrix[i][j]
        distances[i+1] = tempdict
        nodes.append(i+1)


def dijkstra(start):

    global distances
    global nodes
    global unvisited
    global previous
    global visited
    global interface

    # set the values to none for initialization.
    
    unvisited = {node: None for node in nodes}
    previous = {node: None for node in nodes}
    interface = {node: None for node in nodes}
    visited = {node: None for node in nodes}

    current = int(start)
    currentDist = 0
    unvisited[current] = currentDist

    while True:
        for next, distance in distances[current].items():

            if next not in unvisited: continue
            
            newDist = currentDist + distance

            if not unvisited[next] or unvisited[next] > newDist:
                unvisited[next] = newDist
                previous[next] = current

                if not interface[current]:
                    interface[next] = next
                else:
                    interface[next] = interface[current]
                    
        visited[current] = currentDist
        del unvisited[current]
        
        done = 1
        for x in unvisited:
            if unvisited[x]:
                done = 0
                break
        if not unvisited or done:
            break

        elements = [node for node in unvisited.items() if node[1]]

        current, currentDist = sorted(elements, key = lambda x: x[1])[0]


# Function to generate the shortest path using the parent table generated by function dijkstra.
def shortest_path(start, end):
    
    global path

    path = []
    dest = int(end)
    src = int(start)
    path.append(dest)

    while dest != src:
        path.append(previous[dest])
        dest = previous[dest]

    path.reverse()

process_file('input.txt')

for start in range(1,NUM_NODES+1):
    print "\n"
    for end in range(1,NUM_NODES+1):
        dijkstra(start)
        if not previous[int(end)] :
            print "%s to %s :  None"  %(start, end)
        else:
            shortest_path(start,end)
            print "%s to %s : " %(start, end),
            for item in path:
                print str(item) + '  ',
            print ''
            cost = 0
            if visited[int(end)]:
                cost = visited[int(end)]
            #print "The total cost is : ",  cost
#print "\nDestination\tInterface"
#for key in interface:
#    print key,"\t\t", interface[key]
